# 编译过程

## 流程分析

在输入`make ARCH=arm CROSS_COMPILE=aarch64-none-linux-gnu-`后开始编译，开头信息如下：

```bash
scripts/kconfig/conf  --syncconfig Kconfig
  UPD     include/config.h
  CFG     u-boot.cfg
  GEN     include/autoconf.mk
  GEN     include/autoconf.mk.dep
  UPD     include/config/uboot.release
  UPD     include/generated/version_autogenerated.h
  UPD     include/generated/timestamp_autogenerated.h
  UPD     include/generated/dt.h
  ENVC    include/generated/env.txt
  ENVP    include/generated/env.in
  ENVT    include/generated/environment.h
  CC      lib/asm-offsets.s
  UPD     include/generated/generic-asm-offsets.h
  CC      arch/arm/lib/asm-offsets.s
  UPD     include/generated/asm-offsets.h
  HOSTCC  scripts/dtc/dtc.o
  HOSTCC  scripts/dtc/flattree.o
  HOSTCC  scripts/dtc/fstree.o
  HOSTCC  scripts/dtc/data.o
  HOSTCC  scripts/dtc/livetree.o
  HOSTCC  scripts/dtc/treesource.o
  HOSTCC  scripts/dtc/srcpos.o
  HOSTCC  scripts/dtc/checks.o
  HOSTCC  scripts/dtc/util.o
  LEX     scripts/dtc/dtc-lexer.lex.c
  YACC    scripts/dtc/dtc-parser.tab.h
  HOSTCC  scripts/dtc/dtc-lexer.lex.o
  YACC    scripts/dtc/dtc-parser.tab.c
  HOSTCC  scripts/dtc/dtc-parser.tab.o
  HOSTLD  scripts/dtc/dtc
  HOSTCC  tools/file2include.o
  HOSTLD  tools/file2include
  HOSTCC  tools/bmp_logo
  HOSTCC  tools/envcrc.o
  WRAP    tools/generated/lib/crc32.c
  HOSTCC  tools/generated/lib/crc32.o
  WRAP    tools/generated/env/embedded.c
  HOSTCC  tools/generated/env/embedded.o
  WRAP    tools/generated/lib/sha1.c
  HOSTCC  tools/generated/lib/sha1.o
  HOSTLD  tools/envcrc
  HOSTCC  tools/gen_eth_addr
  HOSTCC  tools/gen_ethaddr_crc.o
  WRAP    tools/generated/lib/crc8.c
  HOSTCC  tools/generated/lib/crc8.o
  HOSTLD  tools/gen_ethaddr_crc
  HOSTCC  tools/img2srec
  HOSTCC  tools/mkenvimage.o
  HOSTCC  tools/os_support.o
  HOSTLD  tools/mkenvimage
  HOSTCC  tools/aisimage.o
  HOSTCC  tools/atmelimage.o
  HOSTCC  tools/fit_common.o
  HOSTCC  tools/fit_image.o
  HOSTCC  tools/image-host.o
  WRAP    tools/generated/boot/image-fit.c
  HOSTCC  tools/generated/boot/image-fit.o
  HOSTCC  tools/image-sig-host.o
  WRAP    tools/generated/boot/image-fit-sig.c
  HOSTCC  tools/generated/boot/image-fit-sig.o
  WRAP    tools/generated/boot/image-cipher.c
  HOSTCC  tools/generated/boot/image-cipher.o
  WRAP    tools/generated/boot/fdt_region.c
  HOSTCC  tools/generated/boot/fdt_region.o
  WRAP    tools/generated/boot/bootm.c
  HOSTCC  tools/generated/boot/bootm.o
  HOSTCC  tools/default_image.o
  WRAP    tools/generated/lib/fdtdec_common.c
  HOSTCC  tools/generated/lib/fdtdec_common.o
  WRAP    tools/generated/lib/fdtdec.c
  HOSTCC  tools/generated/lib/fdtdec.o
  WRAP    tools/generated/boot/image.c
  HOSTCC  tools/generated/boot/image.o
  WRAP    tools/generated/boot/image-host.c
  HOSTCC  tools/generated/boot/image-host.o
  HOSTCC  tools/imagetool.o
  HOSTCC  tools/imximage.o
  HOSTCC  tools/imx8image.o
  HOSTCC  tools/imx8mimage.o
  HOSTCC  tools/kwbimage.o
  WRAP    tools/generated/lib/md5.c
  HOSTCC  tools/generated/lib/md5.o
  HOSTCC  tools/lpc32xximage.o
  HOSTCC  tools/mxsimage.o
  HOSTCC  tools/omapimage.o
  HOSTCC  tools/pblimage.o
  HOSTCC  tools/pbl_crc32.o
  HOSTCC  tools/renesas_spkgimage.o
  HOSTCC  tools/sfspl.o
  HOSTCC  tools/vybridimage.o
  HOSTCC  tools/stm32image.o
  WRAP    tools/generated/lib/rc4.c
  HOSTCC  tools/generated/lib/rc4.o
  HOSTCC  tools/rkcommon.o
  HOSTCC  tools/rkimage.o
  HOSTCC  tools/rksd.o
  HOSTCC  tools/rkspi.o
  HOSTCC  tools/socfpgaimage.o
  HOSTCC  tools/sunxi_egon.o
  WRAP    tools/generated/lib/crc16-ccitt.c
  HOSTCC  tools/generated/lib/crc16-ccitt.o
  WRAP    tools/generated/lib/hash-checksum.c
  HOSTCC  tools/generated/lib/hash-checksum.o
  WRAP    tools/generated/lib/sha256.c
  HOSTCC  tools/generated/lib/sha256.o
  WRAP    tools/generated/lib/sha256_common.c
  HOSTCC  tools/generated/lib/sha256_common.o
  WRAP    tools/generated/lib/sha512.c
  HOSTCC  tools/generated/lib/sha512.o
  WRAP    tools/generated/common/hash.c
  HOSTCC  tools/generated/common/hash.o
  HOSTCC  tools/ublimage.o
  HOSTCC  tools/zynqimage.o
  HOSTCC  tools/zynqmpimage.o
  HOSTCC  tools/zynqmpbif.o
  WRAP    tools/generated/lib/fdt-libcrypto.c
  HOSTCC  tools/generated/lib/fdt-libcrypto.o
  HOSTCC  tools/sunxi_toc0.o
  HOSTCC  tools/libfdt/fdt.o
  HOSTCC  tools/libfdt/fdt_ro.o
  HOSTCC  tools/libfdt/fdt_wip.o
  HOSTCC  tools/libfdt/fdt_sw.o
  HOSTCC  tools/libfdt/fdt_rw.o
  HOSTCC  tools/libfdt/fdt_strerror.o
  HOSTCC  tools/libfdt/fdt_empty_tree.o
  HOSTCC  tools/libfdt/fdt_addresses.o
  HOSTCC  tools/libfdt/fdt_overlay.o
  HOSTCC  tools/gpimage.o
  HOSTCC  tools/gpimage-common.o
  HOSTCC  tools/mtk_image.o
  HOSTCC  tools/mtk_nand_headers.o
  WRAP    tools/generated/lib/ecdsa/ecdsa-libcrypto.c
  HOSTCC  tools/generated/lib/ecdsa/ecdsa-libcrypto.o
  WRAP    tools/generated/lib/rsa/rsa-sign.c
  HOSTCC  tools/generated/lib/rsa/rsa-sign.o
  WRAP    tools/generated/lib/rsa/rsa-verify.c
  HOSTCC  tools/generated/lib/rsa/rsa-verify.o
  WRAP    tools/generated/lib/rsa/rsa-mod-exp.c
  HOSTCC  tools/generated/lib/rsa/rsa-mod-exp.o
  WRAP    tools/generated/lib/aes/aes-encrypt.c
  HOSTCC  tools/generated/lib/aes/aes-encrypt.o
  WRAP    tools/generated/lib/aes/aes-decrypt.c
  HOSTCC  tools/generated/lib/aes/aes-decrypt.o
  HOSTCC  tools/dumpimage.o
  HOSTLD  tools/dumpimage
  HOSTCC  tools/mkimage.o
  HOSTLD  tools/mkimage
  HOSTCC  tools/fit_info.o
  HOSTLD  tools/fit_info
  HOSTCC  tools/fit_check_sign.o
  HOSTLD  tools/fit_check_sign
  HOSTCC  tools/fdt_add_pubkey.o
  HOSTLD  tools/fdt_add_pubkey
  HOSTCC  tools/proftool.o
  WRAP    tools/generated/lib/abuf.c
  HOSTCC  tools/generated/lib/abuf.o
  HOSTLD  tools/proftool
  HOSTCC  tools/relocate-rela
  HOSTCC  tools/fdtgrep.o
  HOSTLD  tools/fdtgrep
  HOSTCC  tools/spl_size_limit
  WRAP    tools/generated/lib/uuid.c
  HOSTCC  tools/generated/lib/uuid.o
  HOSTCC  tools/mkeficapsule.o
  HOSTLD  tools/mkeficapsule
tools/bmp_logo --gen-info ./tools/logos/denx.bmp > include/bmp_logo.h
tools/bmp_logo --gen-bmp ./tools/logos/denx.bmp > include/bmp_logo_data.h
  AR      arch/arm/cpu/built-in.o
  CC      arch/arm/cpu/armv8/cpu.o
  CC      arch/arm/cpu/armv8/generic_timer.o
  ...
```

可以总体分为3步：
1. 在最开始检查并更新生成 config.h 等文件
2. 再然后就是制作一系列工具（host 机器使用）
3. 开始交叉编译uboot

*config.h 不是 .config 生成产物，include/generated/autoconf.h 才是，config.h 包含 include/linux/kconfig.h,而 include/linux/kconfig.h 才包含 include/generated/autoconf.h。*

*为什么uboot中会有include/linux目录，AI回答：为了代码重用和与 Linux 生态兼容而设立的重要目录，它使得 U-Boot 能够利用 Linux 内核中成熟的代码基础设施，同时也为驱动开发和系统移植提供了便利。*

*u-boot.cfg 是干什么的？AI回答+我的猜测：首先生成顺序应该是 .config --> autoconf.h --> u-boot.cfg。.config 保存了所有配置选项；autoconf.h 保存由 .config 转换来的C语言宏；u-boot.cfg是保存最终 U-Boot 镜像相关的“展平配置”（C宏的样式），方便查看选择了哪些配置选项。*

*发现对于`CONFIG_XXX=y`翻译到C宏，不是`#define XXX`而是`#define CONFIG_XXX 1`。*

## Makfile分析

*rules 匹配的规则（匹配规则：完整匹配 > 通配符半匹配 > 完全通配符匹配）*

### 顶层Makfile

#### 大体框架

```Makefile
# 变量设置
...

# kbuild supports saving output files in a separate directory.
# To locate output files in a separate directory two syntaxes are supported.
# In both cases the working directory must be the root of the kernel src.
# 1) O=
# Use "make O=dir/to/store/output/files/"
#
# 2) Set KBUILD_OUTPUT
# Set the environment variable KBUILD_OUTPUT to point to the directory
# where the output files shall be placed.
# export KBUILD_OUTPUT=dir/to/store/output/files/
# make
#
# The O= assignment takes precedence over the KBUILD_OUTPUT environment
# variable.

# KBUILD_SRC is set on invocation of make in OBJ directory
# KBUILD_SRC is not intended to be used by the regular user (for now)
# 首次调用时 KBUILD_SRC 为空，如果是设置将编译文件分离单独目录，在之后会第二次调用该Makefile，这时会传入参数。
ifeq ($(KBUILD_SRC),)

# OK, Make called in directory where kernel src resides
# Do we want to locate output files in a separate directory?
ifeq ("$(origin O)", "command line")
  KBUILD_OUTPUT := $(O) # 检查变量 O 是否来自命令行, 命令行优先级大于环境变量
endif

# That's our default target when none is given on the command line
PHONY := _all
_all:

# Cancel implicit rules on top Makefile
# 取消顶层 Makefile 的隐式规则（也就是第一次调用该 Makefile时），防止 make 尝试重建它们
$(CURDIR)/Makefile Makefile: ;

# 如果 KBUILD_OUTPUT 不为空（即指定了输出目录）
ifneq ($(KBUILD_OUTPUT),)
# Invoke a second make in the output directory, passing relevant variables
# check that the output directory actually exists
saved-output := $(KBUILD_OUTPUT)
KBUILD_OUTPUT := $(shell mkdir -p $(KBUILD_OUTPUT) && cd $(KBUILD_OUTPUT) \
								&& /bin/pwd)
$(if $(KBUILD_OUTPUT),, \
     $(error failed to create output directory "$(saved-output)"))

# Look for make include files relative to root of kernel src
#
# This does not become effective immediately because MAKEFLAGS is re-parsed
# once after the Makefile is read.  It is OK since we are going to invoke
# 'sub-make' below.
MAKEFLAGS += --include-dir=$(CURDIR)

PHONY += $(MAKECMDGOALS) sub-make

$(filter-out _all sub-make $(CURDIR)/Makefile, $(MAKECMDGOALS)) _all: sub-make
	@:

# 再次调用该 Makefile 并设置了关键变量
sub-make: FORCE
	$(Q)$(MAKE) -C $(KBUILD_OUTPUT) KBUILD_SRC=$(CURDIR) \
	-f $(CURDIR)/Makefile $(filter-out _all sub-make,$(MAKECMDGOALS))

# Leave processing to above invocation of make
# 跳过第一次 Makefile 中实际编译的内容，这部分需交给第二次调用来做
skip-makefile := 1
endif # ifneq ($(KBUILD_OUTPUT),)
endif # ifeq ($(KBUILD_SRC),)

# We process the rest of the Makefile if this is the final invocation of make
ifeq ($(skip-makefile),)

# 变量设置
# 引入必须的其他文件 如：include scripts/Kbuild.include
...

# 定义自动生成的头文件路径
version_h := include/generated/version_autogenerated.h
timestamp_h := include/generated/timestamp_autogenerated.h
defaultenv_h := include/generated/defaultenv_autogenerated.h
dt_h := include/generated/dt.h
env_h := include/generated/environment.h

no-dot-config-targets := clean clobber mrproper distclean \
			 help %docs check% coccicheck \
			 ubootversion backup tests check pcheck qcheck tcheck \
			 pylint pylint_err _pip pip pip_test pip_release

config-targets := 0 # 标识当前是否在执行配置相关的目标
mixed-targets  := 0 # 标识是否同时指定了配置目标和构建目标
dot-config     := 1 # 控制是否需要读取和使用 .config 文件

ifneq ($(filter $(no-dot-config-targets), $(MAKECMDGOALS)),)
	ifeq ($(filter-out $(no-dot-config-targets), $(MAKECMDGOALS)),)
		dot-config := 0 # 如果只有不需要.config的目标，设置dot-config为0
	endif
endif

ifeq ($(KBUILD_EXTMOD),)
        ifneq ($(filter config %config,$(MAKECMDGOALS)),)
                config-targets := 1 # 检测到*config目标
                ifneq ($(words $(MAKECMDGOALS)),1)
                        mixed-targets := 1 # 检测到混合目标（配置+构建）
                endif
        endif
endif

# 当同时指定配置目标和构建目标时，逐个分开执行当前Makefile
ifeq ($(mixed-targets),1)
# ===========================================================================
# We're called with mixed targets (*config and build targets).
# Handle them one by one.

PHONY += $(MAKECMDGOALS) __build_one_by_one

$(filter-out __build_one_by_one, $(MAKECMDGOALS)): __build_one_by_one
	@:

__build_one_by_one:
	$(Q)set -e; \
	for i in $(MAKECMDGOALS); do \
		$(MAKE) -f $(srctree)/Makefile $$i; \
	done

else # $(mixed-targets)
# 只处理配置目标（如 make menuconfig, make oldconfig）
ifeq ($(config-targets),1)
# ===========================================================================
# *config targets only - make sure prerequisites are updated, and descend
# in scripts/kconfig to make the *config target

KBUILD_DEFCONFIG := sandbox_defconfig
export KBUILD_DEFCONFIG KBUILD_KCONFIG

config: scripts_basic outputmakefile FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@

%config: scripts_basic outputmakefile FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@

else # $(config-targets)
# 处理纯构建目标（如 make all, make u-boot.bin）
# ===========================================================================
# Build targets only - this includes vmlinux, arch specific targets, clean
# targets and others. In general all targets except *config targets.

# Additional helpers built in scripts/
# Carefully list dependencies so we do not try to build scripts twice
# in parallel
PHONY += scripts
scripts: scripts_basic scripts_dtc include/config/auto.conf
	$(Q)$(MAKE) $(build)=$(@)

ifeq ($(dot-config),1)
# Read in config
-include include/config/auto.conf

# Read in dependencies to all Kconfig* files, make sure to run
# oldconfig if changes are detected.
-include include/config/auto.conf.cmd

# To avoid any implicit rule to kick in, define an empty command
$(KCONFIG_CONFIG) include/config/auto.conf.cmd: ;
...

else # $(dot-config)
# 不需要读取 .config 生成的 auto.conf时，伪目标确保 Make 知道如何处理这个文件
# Dummy target needed, because used as prerequisite
include/config/auto.conf: ;
endif # $(dot-config)

# 核心构建，编译u-boot
...

endif # $(config-targets)
endif # $(mixed-targets)
endif	# skip-makefile

PHONY += FORCE
FORCE:

# Declare the contents of the PHONY variable as phony.  We keep that
# information in a variable so we can use it in if_changed and friends.
.PHONY: $(PHONY)
```

*为什么切换目录执行makefile就可以设置编译产物在其他目录生成？核心点是相对路径。那这时又如何找到源文件呢？重点关注`KBUILD_SRC`*

#### 如何编译出u-boot

1. 各个目录生成链接各自的 built_in.o
2. `libs-y`记录需要编译哪些目录的 built_in.o
3. 统一链接，成最终产物

```Makefile
# 通过 -p 获取make执行过程中所使用的所有规则和变量的完整集合，并以 arch/arm/cpu/built-in.o 为例
arch/arm/cpu/built-in.o: FORCE
#  recipe to execute (from 'scripts/Makefile.build', line 333):
	$(call if_changed,link_o_target)
...
# makefile (from 'Makefile', line 908)
libs-y :=  arch/arm/cpu/built-in.o  arch/arm/cpu/armv8/built-in.o ...
...
u-boot: arch/arm/cpu/armv8/start.o arch/arm/cpu/built-in.o ...
#  recipe to execute (from 'Makefile', line 1824):
	+$(call if_changed,u-boot__)
```

#### 子目录 built_in.o

要生成各个目录的 built_in.o，需要“能到各个子目录中编译”，从上面信息可知，实际是在每个目录中执行 Makefile.build。

1. 先收集要编译的子目录放入`u-boot-dirs`，还是根据`libs-y`，如下

     ```Makefile
     u-boot-dirs	:= $(patsubst %/,%,$(filter %/, $(libs-y))) tools examples
     ```

2. 在顶层 Makefile 中递归执行 Makefile.build

    ```Makefile
    PHONY += $(u-boot-dirs)
    $(u-boot-dirs): prepare scripts
    	$(Q)$(MAKE) $(build)=$@

    tools: prepare
    # The "tools" are needed early
    $(filter-out tools, $(u-boot-dirs)): tools
    # The "examples" conditionally depend on U-Boot (say, when USE_PRIVATE_LIBGCC
    # is "yes"), so compile examples after U-Boot is compiled.
    examples: $(filter-out examples, $(u-boot-dirs))
    ```

    以 `drivers` 目录为例，Make会合并相同目标的依赖关系，上面展开就是

    ```Makefile
    drivers: .SHELLSTATUS := 0
    drivers: prepare scripts tools
    #  recipe to execute (from 'Makefile', line 1918):
    	$(Q)$(MAKE) $(build)=$@ # 再展开就是 $(Q)$(MAKE) -f scripts/Makefile.build obj=drivers
    ```

此时，每个目录都能依赖 scripts/Makefile.build ，生成对应 built_in.o。
